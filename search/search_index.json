{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Unreal Ultimate Guide, this page was created to help me in case I forget how to do some stuff. So basically, my potato brain difficult to handle so many stuff, so here we are! Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"Unreal Ultimate Guide, this page was created to help me in case I forget how to do some stuff. So basically, my potato brain difficult to handle so many stuff, so here we are!","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/about/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"about/about/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about/about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"getting-started/unreal-from-source-code/","text":"Pro tips : Use SSD / m.2. Your CPU can't even handle your slower HDD. All step can be found in the official documentation Adding Plugin from Marketplace Adding a plugin that you already purchase on the marketplace is quite troublesome. What you need to do is: Download Unreal Engine that same version as your source engine, just select binary only, so you don't waste your drive space Download the plugin Go to UE4/Plugin and copy the Marketplace folder and paste to your UE4Source/Plugin, use symlink if you want automatically update all plugin. Open GenerateProjectFiles.bat to update the project, so the plugin can be included. Compile the engine","title":"Unreal from Source Code"},{"location":"getting-started/unreal-from-source-code/#adding-plugin-from-marketplace","text":"Adding a plugin that you already purchase on the marketplace is quite troublesome. What you need to do is: Download Unreal Engine that same version as your source engine, just select binary only, so you don't waste your drive space Download the plugin Go to UE4/Plugin and copy the Marketplace folder and paste to your UE4Source/Plugin, use symlink if you want automatically update all plugin. Open GenerateProjectFiles.bat to update the project, so the plugin can be included. Compile the engine","title":"Adding Plugin from Marketplace"},{"location":"programming/programming-guide/","text":"","title":"Programming"},{"location":"programming/cpp/enumbitmask/","text":"Where do we declare it (?) All types are best to be stored inside a class such as GameTypes. Ex : Enum Enum is quite different with c# version. When we create a type of enum, you can do this (as an example) UENUM(BlueprintType) enum SpecialAction { ACT_None = 0 UMETA(DisplayName = \"None\"), ACT_AutoMove = 1 UMETA(DisplayName = \"Auto Move To\"), ACT_Vault = 2 UMETA(DisplayName = \"Vault\"), ACT_Climb1M = 4 UMETA(DisplayName = \"Climb 1M\") , }; To declare the variable, you need TEnumAsByte TEnumAsByte<enum ESpecialAction> SpecialAction; All declaration need that, including params. Bitmask / Flags Not many people know how to do Bitmask in Unreal. By adding meta = (UseEnumValuesAsMaskValuesInEditor=\"true\") your blueprint version will act the None value as 1 value. I'm driving crazy on the process finding this shit! no one mention it! I've found it here https://issues.unrealengine.com/issue/UE-32816 Bitmask / Flags is not quite different with C# version, just a little bit. I'm using this for example : UENUM(BlueprintType, meta=(Bitflags, UseEnumValuesAsMaskValuesInEditor=\"true\")) enum class ESpecialAction : uint8 { ACT_None UMETA(DisplayName = \"None\"), ACT_AutoMove UMETA(DisplayName = \"Auto Move To\"), ACT_Vault UMETA(DisplayName = \"Vault\"), ACT_Climb1M UMETA(DisplayName = \"Climb 1M\") , }; ENUM_CLASS_FLAGS(ESpecialAction) // declaration //can be set as bitmask in blueprnt UPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction)) uint8 SpecialAction; //cannot be set as bitmask in blueprint, so use on c++ only UPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction)) ESpecialAction SpecialActionC;=\"true\"))enum class ESpecialAction : uint8 { ACT_None UMETA(DisplayName = \"None\"), ACT_AutoMove UMETA(DisplayName = \"Auto Move To\"), ACT_Vault UMETA(DisplayName = \"Vault\"), ACT_Climb1M UMETA(DisplayName = \"Climb 1M\") ,};ENUM_CLASS_FLAGS(ESpecialAction)// declaration//can be set as bitmask in blueprntUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))uint8 SpecialAction;//cannot be set as bitmask in blueprint, so use on c++ onlyUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))ESpecialAction SpecialActionC; UENUM(BlueprintType) : This will register the enum as an BlueprintType, so you can access it inside Blueprint version uint8 : Required when implements the Flags / Bitmask version of enum. None = 0 : Must have the 0 version. This will used for checking flag. ENUM_CLASS_FLAGS(Enum) : This register your enum as a flags Non Blueprint Version Add SpecialAction |= ESpecialAction::ACT_AutoMove; Remove SpecialAction &= ~ESpecialAction::ACT_AutoMove; Has if((SpecialAction & ESpecialAction::ACT_Vault) != ESpecialAction::ACT_None) Not / Reverse ~SpecialAction Blueprint Version (uint8) No big different, just cast it to the uint8 / the enum type. Add SpecialAction |= (uint8)ESpecialAction::ACT_AutoMove; Remove SpecialAction &= (uint8)(~ESpecialAction::ACT_AutoMove); Has if((SpecialAction & (uint8)ESpecialAction::ACT_Vault) != (uint8)ESpecialAction::ACT_None) Not / Reverse (uint8)(~SpecialAction)","title":"Enum / Bitmask"},{"location":"programming/cpp/enumbitmask/#where-do-we-declare-it","text":"All types are best to be stored inside a class such as GameTypes. Ex :","title":"Where do we declare it (?)"},{"location":"programming/cpp/enumbitmask/#enum","text":"Enum is quite different with c# version. When we create a type of enum, you can do this (as an example) UENUM(BlueprintType) enum SpecialAction { ACT_None = 0 UMETA(DisplayName = \"None\"), ACT_AutoMove = 1 UMETA(DisplayName = \"Auto Move To\"), ACT_Vault = 2 UMETA(DisplayName = \"Vault\"), ACT_Climb1M = 4 UMETA(DisplayName = \"Climb 1M\") , }; To declare the variable, you need TEnumAsByte TEnumAsByte<enum ESpecialAction> SpecialAction; All declaration need that, including params.","title":"Enum"},{"location":"programming/cpp/enumbitmask/#bitmask-flags","text":"Not many people know how to do Bitmask in Unreal. By adding meta = (UseEnumValuesAsMaskValuesInEditor=\"true\") your blueprint version will act the None value as 1 value. I'm driving crazy on the process finding this shit! no one mention it! I've found it here https://issues.unrealengine.com/issue/UE-32816 Bitmask / Flags is not quite different with C# version, just a little bit. I'm using this for example : UENUM(BlueprintType, meta=(Bitflags, UseEnumValuesAsMaskValuesInEditor=\"true\")) enum class ESpecialAction : uint8 { ACT_None UMETA(DisplayName = \"None\"), ACT_AutoMove UMETA(DisplayName = \"Auto Move To\"), ACT_Vault UMETA(DisplayName = \"Vault\"), ACT_Climb1M UMETA(DisplayName = \"Climb 1M\") , }; ENUM_CLASS_FLAGS(ESpecialAction) // declaration //can be set as bitmask in blueprnt UPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction)) uint8 SpecialAction; //cannot be set as bitmask in blueprint, so use on c++ only UPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction)) ESpecialAction SpecialActionC;=\"true\"))enum class ESpecialAction : uint8 { ACT_None UMETA(DisplayName = \"None\"), ACT_AutoMove UMETA(DisplayName = \"Auto Move To\"), ACT_Vault UMETA(DisplayName = \"Vault\"), ACT_Climb1M UMETA(DisplayName = \"Climb 1M\") ,};ENUM_CLASS_FLAGS(ESpecialAction)// declaration//can be set as bitmask in blueprntUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))uint8 SpecialAction;//cannot be set as bitmask in blueprint, so use on c++ onlyUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))ESpecialAction SpecialActionC; UENUM(BlueprintType) : This will register the enum as an BlueprintType, so you can access it inside Blueprint version uint8 : Required when implements the Flags / Bitmask version of enum. None = 0 : Must have the 0 version. This will used for checking flag. ENUM_CLASS_FLAGS(Enum) : This register your enum as a flags","title":"Bitmask / Flags"},{"location":"programming/cpp/enumbitmask/#non-blueprint-version","text":"","title":"Non Blueprint Version"},{"location":"programming/cpp/enumbitmask/#add","text":"SpecialAction |= ESpecialAction::ACT_AutoMove;","title":"Add"},{"location":"programming/cpp/enumbitmask/#remove","text":"SpecialAction &= ~ESpecialAction::ACT_AutoMove;","title":"Remove"},{"location":"programming/cpp/enumbitmask/#has","text":"if((SpecialAction & ESpecialAction::ACT_Vault) != ESpecialAction::ACT_None)","title":"Has"},{"location":"programming/cpp/enumbitmask/#not-reverse","text":"~SpecialAction","title":"Not / Reverse"},{"location":"programming/cpp/enumbitmask/#blueprint-version-uint8","text":"No big different, just cast it to the uint8 / the enum type.","title":"Blueprint Version (uint8)"},{"location":"programming/cpp/enumbitmask/#add_1","text":"SpecialAction |= (uint8)ESpecialAction::ACT_AutoMove;","title":"Add"},{"location":"programming/cpp/enumbitmask/#remove_1","text":"SpecialAction &= (uint8)(~ESpecialAction::ACT_AutoMove);","title":"Remove"},{"location":"programming/cpp/enumbitmask/#has_1","text":"if((SpecialAction & (uint8)ESpecialAction::ACT_Vault) != (uint8)ESpecialAction::ACT_None)","title":"Has"},{"location":"programming/cpp/enumbitmask/#not-reverse_1","text":"(uint8)(~SpecialAction)","title":"Not / Reverse"},{"location":"programming/cpp/struct/","text":"Struct in unreal has a special macro to enable usage on the Blueprint version. The macro is USTRUCT() . To make it blueprint type, you can pass the BlueprintType inside USTRUCT(BlueprintType) . //If you want this to appear in BP, make sure to use this instead //USTRUCT(BlueprintType) USTRUCT() struct FJoyStruct{ GENERATED_BODY() //Always make USTRUCT variables into UPROPERTY() // any non-UPROPERTY() struct vars are not replicated // So to simplify your life for later debugging, always use UPROPERTY() UPROPERTY() int32 SampleInt32; //If you want the property to appear in BP, make sure to use this instead //UPROPERTY(BlueprintReadOnly) UPROPERTY() AActor* TargetActor; //Set void SetInt(const int32 NewValue) { SampleInt32 = NewValue; } //Get AActor* GetActor() { return TargetActor; } //Check bool ActorIsValid() const { if(!TargetActor) return false; return TargetActor->IsValidLowLevel(); } //Constructor FJoyStruct() { //Always initialize your USTRUCT variables! // exception is if you know the variable type has its own default constructor SampleInt32 = 5; TargetActor = NULL; } }; USTRUCT() struct FParticleStruct{ GENERATED_BODY() UPROPERTY() UParticleSystemComponent* PSCPtr; UPROPERTY() float LifeTime; void SetColor() { // } FLinearColor GetCurrentColor() const { // } //For GC void Destroy() { PSCPtr = nullptr; } //Constructor FParticleStruct() { PSCPtr = NULL; LifeTime = -1; } };","title":"Struct"},{"location":"programming/cpp/tarray/","text":"TArray is array type in unreal. It is supported for blueprint type, so better to use TArray instead of the other type. Some article might worth to checkout : TArray Optimizing TArray","title":"TArray"},{"location":"programming/cpp/variables/","text":"Common Usage Setter Getter is highly recommended. Keep your variable in private / protected is good. When you want to use your variable in the blueprint, use protected and UPROPERTY BlueprintReadWrite / Something else. If you want to use the variable outside of the child class, use public / setter getter. NOTE : if you use set get, dont use blueprintReadWrite at the target variable! Ex: protected: float MoveInput; public: UFUNCTION(BlueprintCallable) FORCEINLINE float GetMoveInput() const {return MoveInput;} Why? You will have, if you have BlueprintRead, inside the Blueprint, when you call GetMoveInput, it will reproduce 2 type of getter. And that was not good for future development. Just make it simple! Int C++ care about memory, don't overdue int usage, just use it as you need with proper size uint = unsigned int = no negative value int = signed int = allow negative value uint8 = 0 \u2014 255 int8 = -128 \u2014 127 uint16 = 0 \u2014 65535 int16 = -32768 \u2014 32767 uint32 = 0 \u2014 -4294967295 int32 = -2147483648 \u2014 2147483647 Size of c-type data Source : https://www.geeksforgeeks.org/c-data-types/ data type size(in bytes) range SHORT INT 2 -32,768 to 32,767 UNSIGNED SHORT INT 2 0 to 65,535 UNSIGNED INT 4 0 TO 4,294,967,295 INT 4 -2,147,483,648 TO 2,147,483,647 LONG INT 8 -2,147,483,648 TO 2,147,483,647 UNSIGNED LONG INT 8 0 TO 4,294,967,295 LONG LONG INT 8 -(2^63) TO (2^63)-1 UNSIGNED LONG LONG INT 8 0 TO 18,446,744,073,709,551,615 SIGNED CHAR 1 -128 TO 127 UNSIGNED CHAR 1 0 TO 255 FLOAT 4 DOUBLE 8 LONG DOUBLE 12 WCHAR_T 2 OR 4 1 WIDE CHARACTER","title":"Variables"},{"location":"programming/cpp/variables/#common-usage","text":"Setter Getter is highly recommended. Keep your variable in private / protected is good. When you want to use your variable in the blueprint, use protected and UPROPERTY BlueprintReadWrite / Something else. If you want to use the variable outside of the child class, use public / setter getter. NOTE : if you use set get, dont use blueprintReadWrite at the target variable! Ex: protected: float MoveInput; public: UFUNCTION(BlueprintCallable) FORCEINLINE float GetMoveInput() const {return MoveInput;} Why? You will have, if you have BlueprintRead, inside the Blueprint, when you call GetMoveInput, it will reproduce 2 type of getter. And that was not good for future development. Just make it simple!","title":"Common Usage"},{"location":"programming/cpp/variables/#int","text":"C++ care about memory, don't overdue int usage, just use it as you need with proper size uint = unsigned int = no negative value int = signed int = allow negative value uint8 = 0 \u2014 255 int8 = -128 \u2014 127 uint16 = 0 \u2014 65535 int16 = -32768 \u2014 32767 uint32 = 0 \u2014 -4294967295 int32 = -2147483648 \u2014 2147483647","title":"Int"},{"location":"programming/cpp/variables/#size-of-c-type-data","text":"Source : https://www.geeksforgeeks.org/c-data-types/ data type size(in bytes) range SHORT INT 2 -32,768 to 32,767 UNSIGNED SHORT INT 2 0 to 65,535 UNSIGNED INT 4 0 TO 4,294,967,295 INT 4 -2,147,483,648 TO 2,147,483,647 LONG INT 8 -2,147,483,648 TO 2,147,483,647 UNSIGNED LONG INT 8 0 TO 4,294,967,295 LONG LONG INT 8 -(2^63) TO (2^63)-1 UNSIGNED LONG LONG INT 8 0 TO 18,446,744,073,709,551,615 SIGNED CHAR 1 -128 TO 127 UNSIGNED CHAR 1 0 TO 255 FLOAT 4 DOUBLE 8 LONG DOUBLE 12 WCHAR_T 2 OR 4 1 WIDE CHARACTER","title":"Size of c-type data"}]}