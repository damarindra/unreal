{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Unreal Ultimate Guide, this page was created to help me in case I forget how to do some stuff. So basically, my potato brain difficult to handle so many stuff, so here we are! Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"Unreal Ultimate Guide, this page was created to help me in case I forget how to do some stuff. So basically, my potato brain difficult to handle so many stuff, so here we are!","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"actor-lifecycle/","text":"Actor lifecycle can be read in the official documentation here .","title":"Actor Life-cycle"},{"location":"plugin/","text":"Unreal Plugin Plugin Links Load Level Async https://indiebrothers.itch.io/ue4-loading-screen-system-plugin-unreal-engine-4 Imgui https://github.com/segross/UnrealImGui UE4Git https://github.com/SRombauts/UE4GitPlugin Dialog System https://gitlab.com/NotYetGames/DlgSystem A lot of plugins https://ue4resources.com/plugins Related to Unreal Plugin Links Mixamo to Unreal (Blender) https://github.com/enziop/mixamo_converter Blender Vector Fields https://github.com/isathar/Blender_UE4_VectorFieldEditor","title":"Plugins"},{"location":"plugin/#unreal-plugin","text":"Plugin Links Load Level Async https://indiebrothers.itch.io/ue4-loading-screen-system-plugin-unreal-engine-4 Imgui https://github.com/segross/UnrealImGui UE4Git https://github.com/SRombauts/UE4GitPlugin Dialog System https://gitlab.com/NotYetGames/DlgSystem A lot of plugins https://ue4resources.com/plugins","title":"Unreal Plugin"},{"location":"plugin/#related-to-unreal","text":"Plugin Links Mixamo to Unreal (Blender) https://github.com/enziop/mixamo_converter Blender Vector Fields https://github.com/isathar/Blender_UE4_VectorFieldEditor","title":"Related to Unreal"},{"location":"about/about/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"about/about/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about/about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"articles/controller-and-camera/","text":"When we start Unreal Engine, we thought Camera and Controller is quite the same, since when we rotate our Controller (AddControllerPitchInput, etc) , camera also rotated. But, it was so wrong! Controller The controller is an actor that control our character/pawn. It just represents the rotation, so when we want to add movement input, we usually doing like this const FRotator Rotation = Controller -> GetControlRotation (); const FRotator YawRotation ( 0 , Rotation . Yaw , 0 ); const FVector Direction = FRotationMatrix ( YawRotation ). GetUnitAxis ( EAxis :: Y ); AddMovementInput ( Direction , Axis ); What Controller doing when we code like this? Camera mimicking the controller, resulting match rotation on some axis between controller and rotation. Camera Camera is controlled by PlayerCameraManager. Usuall,y we don't code it if we just make a simple camera following pawn. Read Player Camera Manager. Camera can be followed by controller rotation whenever we using SpringArmComponent and enable property like inherit controller rotation . Conclusion Controller is an actor that manage how the control will look, it just a representation of the rotation, so we can get forward, right, up direction from the controller, not player pawn. When a Camera using SpringArmComponent and inherit controller rotation , you can imagine your controller is a camera, but it was NOT! Remember this!","title":"Controller and Camera - What the difference?"},{"location":"articles/controller-and-camera/#controller","text":"The controller is an actor that control our character/pawn. It just represents the rotation, so when we want to add movement input, we usually doing like this const FRotator Rotation = Controller -> GetControlRotation (); const FRotator YawRotation ( 0 , Rotation . Yaw , 0 ); const FVector Direction = FRotationMatrix ( YawRotation ). GetUnitAxis ( EAxis :: Y ); AddMovementInput ( Direction , Axis ); What Controller doing when we code like this? Camera mimicking the controller, resulting match rotation on some axis between controller and rotation.","title":"Controller"},{"location":"articles/controller-and-camera/#camera","text":"Camera is controlled by PlayerCameraManager. Usuall,y we don't code it if we just make a simple camera following pawn. Read Player Camera Manager. Camera can be followed by controller rotation whenever we using SpringArmComponent and enable property like inherit controller rotation .","title":"Camera"},{"location":"articles/controller-and-camera/#conclusion","text":"Controller is an actor that manage how the control will look, it just a representation of the rotation, so we can get forward, right, up direction from the controller, not player pawn. When a Camera using SpringArmComponent and inherit controller rotation , you can imagine your controller is a camera, but it was NOT! Remember this!","title":"Conclusion"},{"location":"articles/player-camera-manager/","text":"Unreal makes us easy to make a (specific) game. If you want to make a game that the camera always follows the player, it is easy! But if you want to make an RTS game, you might be confused, even Crash Bandicoot camera type, you might found difficulty with it. You might ask \"But, Crash Bandicoot camera always the following player, right?\", the answer is yes, but in reality, the Crash Bandicoot camera is unique. The camera movement always following where the level goes. That makes it harder for us using Unreal Engine, but if you know how to do it, it easier, so let me introduce you to \"Player Camera Manager\" WTF is Player Camera Manager? Player Camera Manager is a class that have a job to manage camera movement. If you think SpringArmComponent, it is helper only, not the actual controller for camera. So how TF to do it? In PlayerCameraManager, you have 2 choice, using Blueprint or C++. Blueprint Override BlueprintUpdateCamera function, and just create custom movement on it! Set return value to true to make enable it, if false, look at C++ implementation. C++ Override UpdateViewTargetInternal function, copy paste from the original code on it! void ACustomPCM :: UpdateViewTargetInternal ( FTViewTarget & OutVT , float DeltaTime ){ if ( OutVT . Target ){ FVector OutLocation ; FVector OutRotation ; float OutFOV ; if ( BlueprintUpdateCamera ( OutVT . Target , OutLocation , OutRotation , OutFOV )){ OutVT . POV . Location = OutLocation ; OutVT . POV . Rotation = OutRotaion ; OutVT . POV . FOV = OutFOV ; } else { CameraInfo . UpdateViewTarget ( OutVT , GetTransform (), DeltaTime ); } } } Important : You only need to change on the else brackets, just leave the rest as it is. What about Controller (Player Controller) Well, because we modified the camera only, the controller is staying as it is. If you want the controller stays the same as PCM, set the Controller rotation the same as PCM. void ACustomPCM :: UpdateViewTargetInternal ( FTViewTarget & OutVT , float DeltaTime ){ if ( OutVT . Target ){ FVector OutLocation ; FVector OutRotation ; float OutFOV ; if ( BlueprintUpdateCamera ( OutVT . Target , OutLocation , OutRotation , OutFOV )){ OutVT . POV . Location = OutLocation ; OutVT . POV . Rotation = OutRotaion ; OutVT . POV . FOV = OutFOV ; } else { CameraInfo . UpdateViewTarget ( OutVT , GetTransform (), DeltaTime ); PlayerController -> SetControlRotation ( OutVT . POV . Rotation ); } } }","title":"Player Camera Manager - Creating Custom Camera Movement"},{"location":"articles/player-camera-manager/#wtf-is-player-camera-manager","text":"Player Camera Manager is a class that have a job to manage camera movement. If you think SpringArmComponent, it is helper only, not the actual controller for camera.","title":"WTF is Player Camera Manager?"},{"location":"articles/player-camera-manager/#so-how-tf-to-do-it","text":"In PlayerCameraManager, you have 2 choice, using Blueprint or C++.","title":"So how TF to do it?"},{"location":"articles/player-camera-manager/#blueprint","text":"Override BlueprintUpdateCamera function, and just create custom movement on it! Set return value to true to make enable it, if false, look at C++ implementation.","title":"Blueprint"},{"location":"articles/player-camera-manager/#c","text":"Override UpdateViewTargetInternal function, copy paste from the original code on it! void ACustomPCM :: UpdateViewTargetInternal ( FTViewTarget & OutVT , float DeltaTime ){ if ( OutVT . Target ){ FVector OutLocation ; FVector OutRotation ; float OutFOV ; if ( BlueprintUpdateCamera ( OutVT . Target , OutLocation , OutRotation , OutFOV )){ OutVT . POV . Location = OutLocation ; OutVT . POV . Rotation = OutRotaion ; OutVT . POV . FOV = OutFOV ; } else { CameraInfo . UpdateViewTarget ( OutVT , GetTransform (), DeltaTime ); } } } Important : You only need to change on the else brackets, just leave the rest as it is.","title":"C++"},{"location":"articles/player-camera-manager/#what-about-controller-player-controller","text":"Well, because we modified the camera only, the controller is staying as it is. If you want the controller stays the same as PCM, set the Controller rotation the same as PCM. void ACustomPCM :: UpdateViewTargetInternal ( FTViewTarget & OutVT , float DeltaTime ){ if ( OutVT . Target ){ FVector OutLocation ; FVector OutRotation ; float OutFOV ; if ( BlueprintUpdateCamera ( OutVT . Target , OutLocation , OutRotation , OutFOV )){ OutVT . POV . Location = OutLocation ; OutVT . POV . Rotation = OutRotaion ; OutVT . POV . FOV = OutFOV ; } else { CameraInfo . UpdateViewTarget ( OutVT , GetTransform (), DeltaTime ); PlayerController -> SetControlRotation ( OutVT . POV . Rotation ); } } }","title":"What about Controller (Player Controller)"},{"location":"articles/rename-script/","text":"How to do it then? There is 2 Type of renaming, one is really simple, no sweating at all. And the other, you need a lot of step. Simple Rename | Basically rename your script and use redirector | Not Recommend This step is quite simple, the blueprint version of a renamed script is fine. But, the problem is the generated.h is still using the old one. Open DefaultEngine.ini and under section add the below line: [/Script/Engine.Engine] +ActiveClassRedirects=(OldClassName=\u201d/Script/MyAwesomeClass\u201d,NewClassName=\u201d/Script/MyNewClass\u201d) Source : https://unrealxeditor.wordpress.com/2015/05/28/tip-renaming-c-classes-without-breaking-your-project/ Typing help : https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Config/BaseEngine.ini#L240 Easier than below, but it actually the same you need to create a new class for the renamed script. Copy all of the script from old one to the new script. Compile and make sure success. Reparent all the blueprint from the old script to the new script Close UE4 and VS Delete the old script. Delete folders . Also delete the vs, Build, Intermediate, and Saved vs project solution . Right click project file and Generate Visual Studio Project. Rebuild Done! Hard but RECOMMEND! This step is quite complicated. Basically you need a backup, commit and push to git first before doing this action. The idea is, reparent all of the blueprints based on the script that we will rename it. Let\u2019s do it! Reparent all of the blueprints based on the script that we will rename it. Ex: if your script is based on Character, let just call it public class AMyCharacter : ACharacter just reparent the blueprint version to Character, let it be an error, just ignore it for now! Save All! Tips : to see all blueprint that inherit from the class, right click the script in Unreal, select Reference Viewer Close Unreal Engine Rename the and . This basically will slow down your VS. class name file name Fix the script that depends on our renamed script, for example I rename my script with , then find the error script since we have rename the file. Change it into like this #include \u201cMyAwesomeCharacter.h\u201d . MyAwesomeCharacter Change the #include \u201cMyCharactergenerated.h\u201d to \u201cMyAwesomeCharacter.generated.h\u201d Save all changes, close visual studio. If prompt open, just click Save (filter structure changes). Delete folders . Also delete the vs, Build, Intermediate, and Saved vs project solution . Right click project file and Generate Visual Studio Project. Open the project sln. Rebuild Solution. Ctrl + F5 / Open the project. Your Blueprint file is still fine, not corrupted. Still remember our first step? Reparent the blueprint to the renamed class, and now you\u2019re done! (Haven\u2019t Tried it, but worth to try) Using tools Link : https://samcarey.itch.io/ue4-tools-open-source-tool","title":"Renaming Script"},{"location":"articles/rename-script/#how-to-do-it-then","text":"There is 2 Type of renaming, one is really simple, no sweating at all. And the other, you need a lot of step.","title":"How to do it then?"},{"location":"articles/rename-script/#simple-rename-basically-rename-your-script-and-use-redirector-not-recommend","text":"This step is quite simple, the blueprint version of a renamed script is fine. But, the problem is the generated.h is still using the old one. Open DefaultEngine.ini and under section add the below line: [/Script/Engine.Engine] +ActiveClassRedirects=(OldClassName=\u201d/Script/MyAwesomeClass\u201d,NewClassName=\u201d/Script/MyNewClass\u201d) Source : https://unrealxeditor.wordpress.com/2015/05/28/tip-renaming-c-classes-without-breaking-your-project/ Typing help : https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Config/BaseEngine.ini#L240","title":"Simple Rename | Basically rename your script and use redirector | Not Recommend"},{"location":"articles/rename-script/#easier-than-below-but-it-actually-the-same","text":"you need to create a new class for the renamed script. Copy all of the script from old one to the new script. Compile and make sure success. Reparent all the blueprint from the old script to the new script Close UE4 and VS Delete the old script. Delete folders . Also delete the vs, Build, Intermediate, and Saved vs project solution . Right click project file and Generate Visual Studio Project. Rebuild Done!","title":"Easier than below, but it actually the same"},{"location":"articles/rename-script/#hard-but-recommend","text":"This step is quite complicated. Basically you need a backup, commit and push to git first before doing this action. The idea is, reparent all of the blueprints based on the script that we will rename it. Let\u2019s do it! Reparent all of the blueprints based on the script that we will rename it. Ex: if your script is based on Character, let just call it public class AMyCharacter : ACharacter just reparent the blueprint version to Character, let it be an error, just ignore it for now! Save All! Tips : to see all blueprint that inherit from the class, right click the script in Unreal, select Reference Viewer Close Unreal Engine Rename the and . This basically will slow down your VS. class name file name Fix the script that depends on our renamed script, for example I rename my script with , then find the error script since we have rename the file. Change it into like this #include \u201cMyAwesomeCharacter.h\u201d . MyAwesomeCharacter Change the #include \u201cMyCharactergenerated.h\u201d to \u201cMyAwesomeCharacter.generated.h\u201d Save all changes, close visual studio. If prompt open, just click Save (filter structure changes). Delete folders . Also delete the vs, Build, Intermediate, and Saved vs project solution . Right click project file and Generate Visual Studio Project. Open the project sln. Rebuild Solution. Ctrl + F5 / Open the project. Your Blueprint file is still fine, not corrupted. Still remember our first step? Reparent the blueprint to the renamed class, and now you\u2019re done!","title":"Hard but RECOMMEND!"},{"location":"articles/rename-script/#havent-tried-it-but-worth-to-try-using-tools","text":"Link : https://samcarey.itch.io/ue4-tools-open-source-tool","title":"(Haven\u2019t Tried it, but worth to try) Using tools"},{"location":"getting-started/unreal-from-source-code/","text":"Pro tips : Use SSD / m.2. Your CPU can't even handle your slower HDD. All step can be found in the official documentation Adding Plugin from Marketplace Adding a plugin that you already purchase on the marketplace is quite troublesome. What you need to do is: Download Unreal Engine that same version as your source engine, just select binary only, so you don't waste your drive space Download the plugin Go to UE4/Plugin and copy the Marketplace folder and paste to your UE4Source/Plugin, use symlink if you want automatically update all plugin. Open GenerateProjectFiles.bat to update the project, so the plugin can be included. Compile the engine","title":"Unreal from Source Code"},{"location":"getting-started/unreal-from-source-code/#adding-plugin-from-marketplace","text":"Adding a plugin that you already purchase on the marketplace is quite troublesome. What you need to do is: Download Unreal Engine that same version as your source engine, just select binary only, so you don't waste your drive space Download the plugin Go to UE4/Plugin and copy the Marketplace folder and paste to your UE4Source/Plugin, use symlink if you want automatically update all plugin. Open GenerateProjectFiles.bat to update the project, so the plugin can be included. Compile the engine","title":"Adding Plugin from Marketplace"},{"location":"programming/programming-guide/","text":"You can read the official documentation here . Blueprint / C++ Blueprint / C++? Which one? Both of course! Not everything can be achievable using Blueprint, this is why we are using C++. Also, C++ is slow when you want prototyping, this is why Blueprint is top-notch!","title":"Programming"},{"location":"programming/programming-guide/#blueprint-c","text":"Blueprint / C++? Which one? Both of course! Not everything can be achievable using Blueprint, this is why we are using C++. Also, C++ is slow when you want prototyping, this is why Blueprint is top-notch!","title":"Blueprint / C++"},{"location":"programming/cpp/delegate/","text":"Delegate in Unreal has 2 major type (in cpp, has so many variant such as MULTICAST, EVENT, so on). If you want to implement just for the blueprint version, you can create simple method. Otherwise, you can use real delegate Simple, using a method/function // header file UFUNCTION ( BlueprintImplementableEvent ) void ImplementThisOnBlueprint (); //or UFUNCTION ( BLueprintNativeEvent ) void ImplementThisOnBlueprintAndC (); // cpp file //implementation for the BlueprintNativeEvent void SomeClass :: ImplementThisOnBlueprintAndC_Implementation (){ //DO Something } If you using NativeEvent, right click on blueprint event node, and click \"add call to parent function\". Connect the event node to parent node to call the _Implementation version. Real delegate There is 4 types of delegates, Dynamic, SingleCast, MultiCast and Event. Below is the comparison What the difference between Dynamic and Multi-cast Delegates? Dynamic Delegates can be serialized, which means can be bind into Blueprint. Dynamic delegates are also the slowest of all delegate types. Don't use them unless you must. Is any difference between Multi-cast Delegates and Single-cast Delegates except of amount of handling functions (single cast have only one?) Pretty much on point, singlecast is pretty much a direct function pointer, multicast is an array of function pointers. (with some unreal precompiler magic attached) What difference between Events and Multi-cast Delegates? Which way the most appropriate for using them? They are the same thing, if you don't need more than one class to do the broadcast, use an event. How can I know which object was called this Delegate? I can use object pointer as variable? Is it safe? There is no default way that I am aware of, but just passing this works, if set up properly. If you only need to know who called it (for example, while debugging), print the result of GetName() in the bound function. You can pass an object pointer as a variable. I have never encountered any issues while doing so. https://wiki.unrealengine.com/Delegates_In_UE4,_Raw_Cpp_and_BP_Exposed Note : You can only use this on the Component script. Actor can't expose the event. Copied Content Steps Signature You create the signature of the delegate, which declares what inputs any receiving functions should specify. //RamaMeleeWeapon class .h DECLARE_DYNAMIC_MULTICAST_DELEGATE_SixParams ( FRamaMeleeHitSignature , class AActor * , HitActor , class UPrimitiveComponent * , HitComponent , const FVector & , ImpactPoint , const FVector & , ImpactNormal , FName , HitBoneName , const struct FHitResult & , HitResult ); Notice the macro declares that I will be adding 6 parameters, there are similar macros for other quantities of parameters :) DECLARE_DYNAMIC_MULTICAST_DELEGATE_SixParams Calling the Delegate You call the delegate within the class structure where it was defined, making sure to only execute it if it is currently bound, meaning at least 1 entity is listening for this delegate / event. .h //.h //RamaMeleeWeapon class .h //This should be in the class which calls the delegate, and where the signature was defined //This is an instance of the signature that was defined above! FRamaMeleeHitSignature RamaMeleeWeapon_OnHit ; .cpp //.cpp //Only the code that is supposed to initiate the event calls Broadcast() if ( RamaMeleeWeapon_OnHit . IsBound ()) //<~~~~ { RamaMeleeWeapon_OnHit . Broadcast ( Hit . GetActor (), Hit . GetComponent (), Hit . ImpactPoint , Hit . ImpactNormal , Hit . BoneName , Hit ); } Comment from Darkgaze : As the official Multicast docs say: (...)It is always safe to call Broadcast() on a multi-cast delegate, even if nothing is bound. The only time you need to be careful is if you are using a delegate to initialize output variables, which is generally very bad to do.(...) So calling InBound() is not necessary. Only in Single-cast delegates. Responding to the Delegate Anywhere you want, you can declare functions which receive the parameters by type and name specified in the delegate signature. //Any class can add a function that uses the delegate signature and responds to the Broadcast() event UFUNCTION()void RespondToMeleeDamageTaken(AActor* HitActor, UPrimitiveComponent* HitComponent, const FVector& ImpactPoint, const FVector& ImpactNormal, FName HitBoneName, const FHitResult& HitResult) UFUNCTION () void RespondToMeleeDamageTaken ( AActor * HitActor , UPrimitiveComponent * HitComponent , const FVector & ImpactPoint , const FVector & ImpactNormal , FName HitBoneName , const FHitResult & HitResult ) See below to learn how to bind the delegate instance to this function or any number of functions that are present in class instances anywhere in your code base! UFUNCTION() ! Please note that functions that are responding to delegate broadcasts should be UFUNCTION()! If your delegate Broadcast stalls the game for a bit and then doesnt work, it's because you did not make one of your receiving functions a UFUNCTION() <3 Rama Binding To The Delegate Dynamic Delegates RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . AddDynamic ( this , & USomeClass :: RespondToMeleeDamageTaken ); //see above in wiki Multicast Delegates Binding to non-dynamic requires this syntax: RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . AddUObject ( this , & USomeClass :: RespondToMeleeDamageTaken ); //see above in wiki https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates/Multicast Non Multicast Binding a UObject to a non-dynamic, non-multicast delegate requires you to use the following syntax. //in some class cpp fileRamaMeleeWeaponComp->RamaMeleeWeapon_OnHit.BindUObject(this, &USomeClass::RespondToMeleeDamageTaken); //see above in wiki You need to access the delegate where it is stored, in my case this is the RamaMeleeWeaponComponent The idea is you are telling the delegate instance that it is getting a new binding, to this SomeClass insance, which is why you include the this pointer. So this code appears where you want to add the binding to the event/delegate, but it must refer to the one signature instance present in the original class instance. So basically this delegate binding is an agreement between two instances , where one instance is of the class that declares and implements the delegate, and the other instance is any ole' class that has declared the function signature to match the delegate signature. There's nothing abstract here, everything is instances, so you must bind your object instance to the delegate signature instance that is part of the instance of the class that is going to fire off the broadcasting. This is why I have a pointer to RamaMeleeWeaponComp->RamaMeleeWeapon_OnHit, and I am also including the this pointer so that the signature knows about the calling object instance. The reason it is a this pointer is because the code above is run in the object that wants to bind to the delegate, so this is a self-referencing pointer to the UObject we are binding to the delegate. Raw C++ Class Instances Raw delegates are used with non UObject classes, like plugin modules. RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . BindRaw ( this , & FSomeRawCPPClass :: RespondToMeleeDamageTaken ); Slate Class Instances Slate delegates use this syntax: RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . CreateSP ( this , & SSomeSlateClass :: RespondToMeleeDamageTaken ); Binding is Per-Instance Please note that when you bind to the delegate this is a per-instance process! That is why you need to include the this pointer, because whichever instance you are calling the code in, it is that particular instance whose function will get called when the delegate is broadcasted. This means you can choose to have only certain instances of a uobject respond to a delegate, or choose to bind or unbind at any time! BP-Friendly Delegates A BP friendly delegate requires this additional .h code to expose the delegate to Blueprints. //RamaMeleeWeapon.h UPROPERTY ( BlueprintAssignable , Category = \"Rama Melee Weapon\" ) FRamaMeleeHitSignature RamaMeleeWeapon_OnHit ; BP-friendly Delegates should be DYNAMIC_MULTICAST so they can be serialized (saved/loaded) with the BP graph. Level Blueprint Friendly Delegates When you've made BP-friendly delegates on objects that you can place in the level, you can simply right click on the object instance in your level -> Add Event and see your new delegate! So nice! This is an additional benefit of using DYNAMIC_MULTICAST delegates! Multi-cast implies binding multiple of various object instances to the delegate and then firing off the event to everyone from a single .Broadcast, which can include your Level Blueprint as a recipient/listener! Video Example Here is a video on how a C++ delegate created in an actor component in C++ looks and is called in Blueprints! The code in this wiki and this video are from my Melee Weapon Plugin http://www.youtube.com/watch?v=aufEB4TCf30&t=5m24s Skip to 5:24 Further Reading Epic Documentation: https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Delegates/ DYNAMIC_MULTICAST And Other Types There are other delegate types besides DYNAMIC_MULTICAST that are not quite as versatile when it comes to Blueprints. Check out the source code of Delegate.h Runtime / Core / Public / Delegates / Delegate . h For a detailed explanation! Sample from this file: ** * C++ DELEGATES * ----------------------------------------------------------------------------------------------- * * This system allows you to call member functions on C++ objects in a generic, yet type-safe way. * Using delegates, you can dynamically bind to a member function of an arbitrary object, * then call functions on the object, even if the caller doesn't know the object's type. * * The system predefines various combinations of generic function signatures with which you can * declare a delegate type from, filling in the type names for return value and parameters with * whichever types you need. * * Both single-cast and multi-cast delegates are supported, as well as \"dynamic\" delegates which * can be safely serialized to disk. Additionally, delegates may define \"payload\" data which * will stored and passed directly to bound functions. Conclusion Enjoy using delegates in UE4 so that any part of your code base can respond to an event triggered by one section of your code! Also enjoy exposing delegates via C++ for the rest of your team to use in Blueprints! Enjoooy!","title":"Delegate"},{"location":"programming/cpp/delegate/#simple-using-a-methodfunction","text":"// header file UFUNCTION ( BlueprintImplementableEvent ) void ImplementThisOnBlueprint (); //or UFUNCTION ( BLueprintNativeEvent ) void ImplementThisOnBlueprintAndC (); // cpp file //implementation for the BlueprintNativeEvent void SomeClass :: ImplementThisOnBlueprintAndC_Implementation (){ //DO Something } If you using NativeEvent, right click on blueprint event node, and click \"add call to parent function\". Connect the event node to parent node to call the _Implementation version.","title":"Simple, using a method/function"},{"location":"programming/cpp/delegate/#real-delegate","text":"There is 4 types of delegates, Dynamic, SingleCast, MultiCast and Event. Below is the comparison","title":"Real delegate"},{"location":"programming/cpp/delegate/#what-the-difference-between-dynamic-and-multi-cast-delegates","text":"Dynamic Delegates can be serialized, which means can be bind into Blueprint. Dynamic delegates are also the slowest of all delegate types. Don't use them unless you must.","title":"What the difference between Dynamic and Multi-cast Delegates?"},{"location":"programming/cpp/delegate/#is-any-difference-between-multi-cast-delegates-and-single-cast-delegates-except-of-amount-of-handling-functions-single-cast-have-only-one","text":"Pretty much on point, singlecast is pretty much a direct function pointer, multicast is an array of function pointers. (with some unreal precompiler magic attached)","title":"Is any difference between Multi-cast Delegates and Single-cast Delegates except of amount of handling functions (single cast have only one?)"},{"location":"programming/cpp/delegate/#what-difference-between-events-and-multi-cast-delegates-which-way-the-most-appropriate-for-using-them","text":"They are the same thing, if you don't need more than one class to do the broadcast, use an event.","title":"What difference between Events and Multi-cast Delegates? Which way the most appropriate for using them?"},{"location":"programming/cpp/delegate/#how-can-i-know-which-object-was-called-this-delegate-i-can-use-object-pointer-as-variable-is-it-safe","text":"There is no default way that I am aware of, but just passing this works, if set up properly. If you only need to know who called it (for example, while debugging), print the result of GetName() in the bound function. You can pass an object pointer as a variable. I have never encountered any issues while doing so. https://wiki.unrealengine.com/Delegates_In_UE4,_Raw_Cpp_and_BP_Exposed Note : You can only use this on the Component script. Actor can't expose the event.","title":"How can I know which object was called this Delegate? I can use object pointer as variable? Is it safe?"},{"location":"programming/cpp/delegate/#copied-content","text":"","title":"Copied Content"},{"location":"programming/cpp/delegate/#steps","text":"Signature You create the signature of the delegate, which declares what inputs any receiving functions should specify. //RamaMeleeWeapon class .h DECLARE_DYNAMIC_MULTICAST_DELEGATE_SixParams ( FRamaMeleeHitSignature , class AActor * , HitActor , class UPrimitiveComponent * , HitComponent , const FVector & , ImpactPoint , const FVector & , ImpactNormal , FName , HitBoneName , const struct FHitResult & , HitResult ); Notice the macro declares that I will be adding 6 parameters, there are similar macros for other quantities of parameters :) DECLARE_DYNAMIC_MULTICAST_DELEGATE_SixParams Calling the Delegate You call the delegate within the class structure where it was defined, making sure to only execute it if it is currently bound, meaning at least 1 entity is listening for this delegate / event. .h //.h //RamaMeleeWeapon class .h //This should be in the class which calls the delegate, and where the signature was defined //This is an instance of the signature that was defined above! FRamaMeleeHitSignature RamaMeleeWeapon_OnHit ; .cpp //.cpp //Only the code that is supposed to initiate the event calls Broadcast() if ( RamaMeleeWeapon_OnHit . IsBound ()) //<~~~~ { RamaMeleeWeapon_OnHit . Broadcast ( Hit . GetActor (), Hit . GetComponent (), Hit . ImpactPoint , Hit . ImpactNormal , Hit . BoneName , Hit ); } Comment from Darkgaze : As the official Multicast docs say: (...)It is always safe to call Broadcast() on a multi-cast delegate, even if nothing is bound. The only time you need to be careful is if you are using a delegate to initialize output variables, which is generally very bad to do.(...) So calling InBound() is not necessary. Only in Single-cast delegates. Responding to the Delegate Anywhere you want, you can declare functions which receive the parameters by type and name specified in the delegate signature. //Any class can add a function that uses the delegate signature and responds to the Broadcast() event UFUNCTION()void RespondToMeleeDamageTaken(AActor* HitActor, UPrimitiveComponent* HitComponent, const FVector& ImpactPoint, const FVector& ImpactNormal, FName HitBoneName, const FHitResult& HitResult) UFUNCTION () void RespondToMeleeDamageTaken ( AActor * HitActor , UPrimitiveComponent * HitComponent , const FVector & ImpactPoint , const FVector & ImpactNormal , FName HitBoneName , const FHitResult & HitResult ) See below to learn how to bind the delegate instance to this function or any number of functions that are present in class instances anywhere in your code base!","title":"Steps"},{"location":"programming/cpp/delegate/#ufunction","text":"Please note that functions that are responding to delegate broadcasts should be UFUNCTION()! If your delegate Broadcast stalls the game for a bit and then doesnt work, it's because you did not make one of your receiving functions a UFUNCTION() <3 Rama","title":"UFUNCTION()\u00a0!"},{"location":"programming/cpp/delegate/#binding-to-the-delegate","text":"","title":"Binding To The Delegate"},{"location":"programming/cpp/delegate/#dynamic-delegates","text":"RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . AddDynamic ( this , & USomeClass :: RespondToMeleeDamageTaken ); //see above in wiki","title":"Dynamic Delegates"},{"location":"programming/cpp/delegate/#multicast-delegates","text":"Binding to non-dynamic requires this syntax: RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . AddUObject ( this , & USomeClass :: RespondToMeleeDamageTaken ); //see above in wiki https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates/Multicast","title":"Multicast Delegates"},{"location":"programming/cpp/delegate/#non-multicast","text":"Binding a UObject to a non-dynamic, non-multicast delegate requires you to use the following syntax. //in some class cpp fileRamaMeleeWeaponComp->RamaMeleeWeapon_OnHit.BindUObject(this, &USomeClass::RespondToMeleeDamageTaken); //see above in wiki You need to access the delegate where it is stored, in my case this is the RamaMeleeWeaponComponent The idea is you are telling the delegate instance that it is getting a new binding, to this SomeClass insance, which is why you include the this pointer. So this code appears where you want to add the binding to the event/delegate, but it must refer to the one signature instance present in the original class instance. So basically this delegate binding is an agreement between two instances , where one instance is of the class that declares and implements the delegate, and the other instance is any ole' class that has declared the function signature to match the delegate signature. There's nothing abstract here, everything is instances, so you must bind your object instance to the delegate signature instance that is part of the instance of the class that is going to fire off the broadcasting. This is why I have a pointer to RamaMeleeWeaponComp->RamaMeleeWeapon_OnHit, and I am also including the this pointer so that the signature knows about the calling object instance. The reason it is a this pointer is because the code above is run in the object that wants to bind to the delegate, so this is a self-referencing pointer to the UObject we are binding to the delegate.","title":"Non Multicast"},{"location":"programming/cpp/delegate/#raw-c-class-instances","text":"Raw delegates are used with non UObject classes, like plugin modules. RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . BindRaw ( this , & FSomeRawCPPClass :: RespondToMeleeDamageTaken );","title":"Raw C++ Class Instances"},{"location":"programming/cpp/delegate/#slate-class-instances","text":"Slate delegates use this syntax: RamaMeleeWeaponComp -> RamaMeleeWeapon_OnHit . CreateSP ( this , & SSomeSlateClass :: RespondToMeleeDamageTaken );","title":"Slate Class Instances"},{"location":"programming/cpp/delegate/#binding-is-per-instance","text":"Please note that when you bind to the delegate this is a per-instance process! That is why you need to include the this pointer, because whichever instance you are calling the code in, it is that particular instance whose function will get called when the delegate is broadcasted. This means you can choose to have only certain instances of a uobject respond to a delegate, or choose to bind or unbind at any time!","title":"Binding is Per-Instance"},{"location":"programming/cpp/delegate/#bp-friendly-delegates","text":"A BP friendly delegate requires this additional .h code to expose the delegate to Blueprints. //RamaMeleeWeapon.h UPROPERTY ( BlueprintAssignable , Category = \"Rama Melee Weapon\" ) FRamaMeleeHitSignature RamaMeleeWeapon_OnHit ; BP-friendly Delegates should be DYNAMIC_MULTICAST so they can be serialized (saved/loaded) with the BP graph.","title":"BP-Friendly Delegates"},{"location":"programming/cpp/delegate/#level-blueprint-friendly-delegates","text":"When you've made BP-friendly delegates on objects that you can place in the level, you can simply right click on the object instance in your level -> Add Event and see your new delegate! So nice! This is an additional benefit of using DYNAMIC_MULTICAST delegates! Multi-cast implies binding multiple of various object instances to the delegate and then firing off the event to everyone from a single .Broadcast, which can include your Level Blueprint as a recipient/listener!","title":"Level Blueprint Friendly Delegates"},{"location":"programming/cpp/delegate/#video-example","text":"Here is a video on how a C++ delegate created in an actor component in C++ looks and is called in Blueprints! The code in this wiki and this video are from my Melee Weapon Plugin http://www.youtube.com/watch?v=aufEB4TCf30&t=5m24s Skip to 5:24","title":"Video Example"},{"location":"programming/cpp/delegate/#further-reading","text":"Epic Documentation: https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Delegates/","title":"Further Reading"},{"location":"programming/cpp/delegate/#dynamic_multicast-and-other-types","text":"There are other delegate types besides DYNAMIC_MULTICAST that are not quite as versatile when it comes to Blueprints. Check out the source code of Delegate.h Runtime / Core / Public / Delegates / Delegate . h For a detailed explanation! Sample from this file: ** * C++ DELEGATES * ----------------------------------------------------------------------------------------------- * * This system allows you to call member functions on C++ objects in a generic, yet type-safe way. * Using delegates, you can dynamically bind to a member function of an arbitrary object, * then call functions on the object, even if the caller doesn't know the object's type. * * The system predefines various combinations of generic function signatures with which you can * declare a delegate type from, filling in the type names for return value and parameters with * whichever types you need. * * Both single-cast and multi-cast delegates are supported, as well as \"dynamic\" delegates which * can be safely serialized to disk. Additionally, delegates may define \"payload\" data which * will stored and passed directly to bound functions.","title":"DYNAMIC_MULTICAST And Other Types"},{"location":"programming/cpp/delegate/#conclusion","text":"Enjoy using delegates in UE4 so that any part of your code base can respond to an event triggered by one section of your code! Also enjoy exposing delegates via C++ for the rest of your team to use in Blueprints! Enjoooy!","title":"Conclusion"},{"location":"programming/cpp/display-priority/","text":"Set the priority on your details panel is so important when you inheriting other classes. Sometimes, you need to make a property that must be below some other property from the base class. For example, I made a script that inherits from CharacterMovementComponent and I want to place my SprintSpeed right after WalkSpeed . The latest property will always result on the bottom, you can re-order this using UProperty option. UPROPERTY Property Details DisplayAfter=\"PropertyName\" This property will show up in the Blueprint Editor immediately after the property named PropertyName, regardless of its order in source code, as long as both properties are in the same category. If multiple properties have the same DisplayAfter value and the same DisplayPriority value, they will appear after the named property in the order in which they are declared in the header file. DisplayPriority=\"N\" If two properties feature the same DisplayAfter value, or are in the same category and do not have the DisplayAfter Meta Tag, this property will determine their sorting order. The highest-priority value is 1, meaning that a property with a DisplayPriority value of 1 will appear above a property with a DisplayProirity value of 2. If multiple properties have the same DisplayAfter value, they will appear in the order in which they are declared in the header file. UCLASS Property Details HideCategories=(Category1, Category2) Lists one or more categories that should be hidden from the user entirely. To hide properties declared with no category, use the name of the class which declares the variable. This Specifier is propagated to child classes.","title":"Display Priority"},{"location":"programming/cpp/display-priority/#uproperty","text":"Property Details DisplayAfter=\"PropertyName\" This property will show up in the Blueprint Editor immediately after the property named PropertyName, regardless of its order in source code, as long as both properties are in the same category. If multiple properties have the same DisplayAfter value and the same DisplayPriority value, they will appear after the named property in the order in which they are declared in the header file. DisplayPriority=\"N\" If two properties feature the same DisplayAfter value, or are in the same category and do not have the DisplayAfter Meta Tag, this property will determine their sorting order. The highest-priority value is 1, meaning that a property with a DisplayPriority value of 1 will appear above a property with a DisplayProirity value of 2. If multiple properties have the same DisplayAfter value, they will appear in the order in which they are declared in the header file.","title":"UPROPERTY"},{"location":"programming/cpp/display-priority/#uclass","text":"Property Details HideCategories=(Category1, Category2) Lists one or more categories that should be hidden from the user entirely. To hide properties declared with no category, use the name of the class which declares the variable. This Specifier is propagated to child classes.","title":"UCLASS"},{"location":"programming/cpp/enumbitmask/","text":"How to setup? All types are best to be stored inside a class such as GameTypes. Important! Enum/struct is better to be placed on a specific class/file. Why? Unreal can't use forward declaration on enum/struct. When you want to use this type on other class header file, you need to #include \"file.h\" and it will resulting problem. Unreal doesn't like it. So create new file classes like GameTypes and place all your enum/struct inside it. If enum/struct only used in one class, it is fine to declared at those classes, but if used in many classes, better on separate file. Ex : Enum Enum is quite different with c# version. When we create a type of enum, you can do this (as an example) UENUM(BlueprintType) enum SpecialAction { ACT_None = 0 UMETA(DisplayName = \"None\"), ACT_AutoMove = 1 UMETA(DisplayName = \"Auto Move To\"), ACT_Vault = 2 UMETA(DisplayName = \"Vault\"), ACT_Climb1M = 4 UMETA(DisplayName = \"Climb 1M\") , }; To declare the variable, you need TEnumAsByte TEnumAsByte<enum ESpecialAction> SpecialAction; All declaration need that, including params. Bitmask / Flags Not many people know how to do Bitmask in Unreal. By adding meta = (UseEnumValuesAsMaskValuesInEditor=\"true\") your blueprint version will act the None value as 1 value. I'm driving crazy on the process finding this shit! no one mention it! I've found it here https://issues.unrealengine.com/issue/UE-32816 Bitmask / Flags is not quite different with C# version, just a little bit. I'm using this for example : UENUM ( BlueprintType , meta = ( Bitflags , UseEnumValuesAsMaskValuesInEditor = \"true\" )) enum class ESpecialAction : uint8 { ACT_None UMETA ( DisplayName = \"None\" ), ACT_AutoMove UMETA ( DisplayName = \"Auto Move To\" ), ACT_Vault UMETA ( DisplayName = \"Vault\" ), ACT_Climb1M UMETA ( DisplayName = \"Climb 1M\" ) , }; ENUM_CLASS_FLAGS ( ESpecialAction ) // declaration //can be set as bitmask in blueprnt UPROPERTY ( EditAnywhere , meta = ( Bitmask , BitmaskEnum = ESpecialAction )) uint8 SpecialAction ; //cannot be set as bitmask in blueprint, so use on c++ only UPROPERTY ( EditAnywhere , meta = ( Bitmask , BitmaskEnum = ESpecialAction )) ESpecialAction SpecialActionC ; = \"true\" )) enum class ESpecialAction : uint8 { ACT_None UMETA ( DisplayName = \"None\" ), ACT_AutoMove UMETA ( DisplayName = \"Auto Move To\" ), ACT_Vault UMETA ( DisplayName = \"Vault\" ), ACT_Climb1M UMETA ( DisplayName = \"Climb 1M\" ) ,}; ENUM_CLASS_FLAGS ( ESpecialAction ) // declaration//can be set as bitmask in blueprntUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))uint8 SpecialAction;//cannot be set as bitmask in blueprint, so use on c++ onlyUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))ESpecialAction SpecialActionC; UENUM(BlueprintType) : This will register the enum as an BlueprintType, so you can access it inside Blueprint version uint8 : Required when implements the Flags / Bitmask version of enum. None = 0 : Must have the 0 version. This will used for checking flag. ENUM_CLASS_FLAGS(Enum) : This register your enum as a flags Non Blueprint Version Add SpecialAction |= ESpecialAction::ACT_AutoMove; Remove SpecialAction &= ~ESpecialAction::ACT_AutoMove; Has if((SpecialAction & ESpecialAction::ACT_Vault) != ESpecialAction::ACT_None) Not / Reverse ~SpecialAction Blueprint Version (uint8) No big different, just cast it to the uint8 / the enum type. Add SpecialAction |= (uint8)ESpecialAction::ACT_AutoMove; Remove SpecialAction &= (uint8)(~ESpecialAction::ACT_AutoMove); Has if((SpecialAction & (uint8)ESpecialAction::ACT_Vault) != (uint8)ESpecialAction::ACT_None) Not / Reverse (uint8)(~SpecialAction)","title":"Enum / Bitmask"},{"location":"programming/cpp/enumbitmask/#how-to-setup","text":"All types are best to be stored inside a class such as GameTypes. Important! Enum/struct is better to be placed on a specific class/file. Why? Unreal can't use forward declaration on enum/struct. When you want to use this type on other class header file, you need to #include \"file.h\" and it will resulting problem. Unreal doesn't like it. So create new file classes like GameTypes and place all your enum/struct inside it. If enum/struct only used in one class, it is fine to declared at those classes, but if used in many classes, better on separate file. Ex :","title":"How to setup?"},{"location":"programming/cpp/enumbitmask/#enum","text":"Enum is quite different with c# version. When we create a type of enum, you can do this (as an example) UENUM(BlueprintType) enum SpecialAction { ACT_None = 0 UMETA(DisplayName = \"None\"), ACT_AutoMove = 1 UMETA(DisplayName = \"Auto Move To\"), ACT_Vault = 2 UMETA(DisplayName = \"Vault\"), ACT_Climb1M = 4 UMETA(DisplayName = \"Climb 1M\") , }; To declare the variable, you need TEnumAsByte TEnumAsByte<enum ESpecialAction> SpecialAction; All declaration need that, including params.","title":"Enum"},{"location":"programming/cpp/enumbitmask/#bitmask-flags","text":"Not many people know how to do Bitmask in Unreal. By adding meta = (UseEnumValuesAsMaskValuesInEditor=\"true\") your blueprint version will act the None value as 1 value. I'm driving crazy on the process finding this shit! no one mention it! I've found it here https://issues.unrealengine.com/issue/UE-32816 Bitmask / Flags is not quite different with C# version, just a little bit. I'm using this for example : UENUM ( BlueprintType , meta = ( Bitflags , UseEnumValuesAsMaskValuesInEditor = \"true\" )) enum class ESpecialAction : uint8 { ACT_None UMETA ( DisplayName = \"None\" ), ACT_AutoMove UMETA ( DisplayName = \"Auto Move To\" ), ACT_Vault UMETA ( DisplayName = \"Vault\" ), ACT_Climb1M UMETA ( DisplayName = \"Climb 1M\" ) , }; ENUM_CLASS_FLAGS ( ESpecialAction ) // declaration //can be set as bitmask in blueprnt UPROPERTY ( EditAnywhere , meta = ( Bitmask , BitmaskEnum = ESpecialAction )) uint8 SpecialAction ; //cannot be set as bitmask in blueprint, so use on c++ only UPROPERTY ( EditAnywhere , meta = ( Bitmask , BitmaskEnum = ESpecialAction )) ESpecialAction SpecialActionC ; = \"true\" )) enum class ESpecialAction : uint8 { ACT_None UMETA ( DisplayName = \"None\" ), ACT_AutoMove UMETA ( DisplayName = \"Auto Move To\" ), ACT_Vault UMETA ( DisplayName = \"Vault\" ), ACT_Climb1M UMETA ( DisplayName = \"Climb 1M\" ) ,}; ENUM_CLASS_FLAGS ( ESpecialAction ) // declaration//can be set as bitmask in blueprntUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))uint8 SpecialAction;//cannot be set as bitmask in blueprint, so use on c++ onlyUPROPERTY(EditAnywhere, meta = (Bitmask, BitmaskEnum=ESpecialAction))ESpecialAction SpecialActionC; UENUM(BlueprintType) : This will register the enum as an BlueprintType, so you can access it inside Blueprint version uint8 : Required when implements the Flags / Bitmask version of enum. None = 0 : Must have the 0 version. This will used for checking flag. ENUM_CLASS_FLAGS(Enum) : This register your enum as a flags","title":"Bitmask / Flags"},{"location":"programming/cpp/enumbitmask/#non-blueprint-version","text":"","title":"Non Blueprint Version"},{"location":"programming/cpp/enumbitmask/#add","text":"SpecialAction |= ESpecialAction::ACT_AutoMove;","title":"Add"},{"location":"programming/cpp/enumbitmask/#remove","text":"SpecialAction &= ~ESpecialAction::ACT_AutoMove;","title":"Remove"},{"location":"programming/cpp/enumbitmask/#has","text":"if((SpecialAction & ESpecialAction::ACT_Vault) != ESpecialAction::ACT_None)","title":"Has"},{"location":"programming/cpp/enumbitmask/#not-reverse","text":"~SpecialAction","title":"Not / Reverse"},{"location":"programming/cpp/enumbitmask/#blueprint-version-uint8","text":"No big different, just cast it to the uint8 / the enum type.","title":"Blueprint Version (uint8)"},{"location":"programming/cpp/enumbitmask/#add_1","text":"SpecialAction |= (uint8)ESpecialAction::ACT_AutoMove;","title":"Add"},{"location":"programming/cpp/enumbitmask/#remove_1","text":"SpecialAction &= (uint8)(~ESpecialAction::ACT_AutoMove);","title":"Remove"},{"location":"programming/cpp/enumbitmask/#has_1","text":"if((SpecialAction & (uint8)ESpecialAction::ACT_Vault) != (uint8)ESpecialAction::ACT_None)","title":"Has"},{"location":"programming/cpp/enumbitmask/#not-reverse_1","text":"(uint8)(~SpecialAction)","title":"Not / Reverse"},{"location":"programming/cpp/logging/","text":"Logging an FString UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *YourActor->GetName()); Logging a Bool UE_LOG(LogTemp, Warning, TEXT(\"%s\"), ( bYourBool ? TEXT(\"true\") : TEXT(\"false\") )); Logging an Integer UE_LOG(LogTemp, Warning, TEXT(\"%d\"), YourInteger); Logging a Float UE_LOG(LogTemp, Warning, TEXT(\"%f\"), YourFloat); Logging an FVector UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *YourVector.ToString()); Logging an Enum UE_LOG(LogTemp, Warning, TEXT(\"%s\"), *StaticEnum<ECollisionChannel>()->GetValueAsString(OutHit.Component->GetCollisionObjectType()));","title":"Logging"},{"location":"programming/cpp/math/","text":"List of useful function that frequently used. What C++ Blueprint Direction to Rotator FRotationMatrix::MakeFromX(YourVector).Rotator() Vector.MakeFromX Rotator to Direction FRotationMatrix(YourRotator).GetUnitAxis(EAxis::X) Rotator.GetUnitAxis World to Local Transform.InverseTransformVector(Vector) Transform.InverseTransformLocation Local to World Transform.TransformVector(Vector) Transform.TransformLocation World to Local No Scale Transform.InverseTransformVectorNoScale(Vector) Local to World No Scale Transform.TransformVectorNoScale(Vector) Rotate a Vector Vector.RotateAngleAxis(Angle, Axis)","title":"Math"},{"location":"programming/cpp/preprocessor/","text":"Preprocessor is useful in some parts, especially specify code that running on the specific platform. WITH_EDITORONLY_DATA Used for property / variable that you want to use in Editor only. WITH_EDITOR Used for any code that run / read on Editor only, including function definition #if WITH_EDITORONLY_DATA bool isDebugMode = false ; #endif #if WITH_EDITOR UFUNCTION ( Exec ) void EnableDebugMode ( bool Enable = false ); #endif","title":"PREPROCESSOR"},{"location":"programming/cpp/preprocessor/#with_editoronly_data","text":"Used for property / variable that you want to use in Editor only.","title":"WITH_EDITORONLY_DATA"},{"location":"programming/cpp/preprocessor/#with_editor","text":"Used for any code that run / read on Editor only, including function definition #if WITH_EDITORONLY_DATA bool isDebugMode = false ; #endif #if WITH_EDITOR UFUNCTION ( Exec ) void EnableDebugMode ( bool Enable = false ); #endif","title":"WITH_EDITOR"},{"location":"programming/cpp/reference/","text":"This just a simple guide about the reference in unreal cpp. Passing Class Reference TSubclassOf < class AActorClass > ActorClass ; SomeFunction ( ActorClass -> GetClass ()); Pointer Reference Basically, any UObject type needs to use a pointer. What about reference? You can passing reference to the parameter, even when the type is pointer such as Don't confuse with reference, it is just like a regular variable, but connected to the original variable.","title":"Reference"},{"location":"programming/cpp/reference/#passing-class-reference","text":"TSubclassOf < class AActorClass > ActorClass ; SomeFunction ( ActorClass -> GetClass ());","title":"Passing Class Reference"},{"location":"programming/cpp/reference/#pointer-reference","text":"Basically, any UObject type needs to use a pointer.","title":"Pointer Reference"},{"location":"programming/cpp/reference/#what-about-reference","text":"You can passing reference to the parameter, even when the type is pointer such as Don't confuse with reference, it is just like a regular variable, but connected to the original variable.","title":"What about reference?"},{"location":"programming/cpp/static-variable/","text":"Static variable in cpp is unique (I have experience on C# before). So, when creating static variable, you can't access it just like that. What you need to do is declaring that static variable into cpp file. // .h struct FSimpleStruct { static FSimpleStruct Instance ; } // .cpp FSimpleStruct FSimpleStruct :: Instance ;","title":"Static Variable"},{"location":"programming/cpp/string/","text":"Unreal has some type for handling string. The tl:dr; version is TEXT() is your friend! Use this to create any type of string. FName is cheaper, but case-insensitive. It is immutable (can't be manipulated) FText is for user. Everything that users see, better using FText . FText support localization, that's means you can formatting this text, localized text, and so on. FString is expensive. This like pure string in the other language. If you want complete guide on string handling, you can read official documentation .","title":"String Handling"},{"location":"programming/cpp/struct/","text":"Struct in unreal has a special macro to enable usage on the Blueprint version. The macro is USTRUCT() . To make it blueprint type, you can pass the BlueprintType inside USTRUCT(BlueprintType) . Important! Enum/struct is better to be placed on a specific class/file. Why? Unreal can't use forward declaration on enum/struct. When you want to use this type on other class header file, you need to #include \"file.h\" and it will resulting problem. Unreal doesn't like it. So create new file classes like GameTypes and place all your enum/struct inside it. If enum/struct only used in one class, it is fine to declared at those classes, but if used in many classes, better on separate file. //If you want this to appear in BP, make sure to use this instead //USTRUCT(BlueprintType) USTRUCT () struct FJoyStruct { GENERATED_BODY () //Always make USTRUCT variables into UPROPERTY() // any non-UPROPERTY() struct vars are not replicated // So to simplify your life for later debugging, always use UPROPERTY() UPROPERTY () int32 SampleInt32 ; //If you want the property to appear in BP, make sure to use this instead //UPROPERTY(BlueprintReadOnly) UPROPERTY () AActor * TargetActor ; //Set void SetInt ( const int32 NewValue ) { SampleInt32 = NewValue ; } //Get AActor * GetActor () { return TargetActor ; } //Check bool ActorIsValid () const { if ( ! TargetActor ) return false ; return TargetActor -> IsValidLowLevel (); } //Constructor FJoyStruct () { //Always initialize your USTRUCT variables! // exception is if you know the variable type has its own default constructor SampleInt32 = 5 ; TargetActor = NULL ; } }; USTRUCT () struct FParticleStruct { GENERATED_BODY () UPROPERTY () UParticleSystemComponent * PSCPtr ; UPROPERTY () float LifeTime ; void SetColor () { // } FLinearColor GetCurrentColor () const { // } //For GC void Destroy () { PSCPtr = nullptr ; } //Constructor FParticleStruct () { PSCPtr = NULL ; LifeTime = -1 ; } };","title":"Struct"},{"location":"programming/cpp/tarray/","text":"TArray is array type in unreal. It is supported for blueprint type, so better to use TArray instead of the other type. Some article might worth to checkout : TArray Optimizing TArray","title":"TArray"},{"location":"programming/cpp/uproperty-ufunction/","text":"UProperty and UFunction is macro to make any property or function can interact with Blueprint. You can read all the metadata at here UPROPERTY Not Meta UPROPERTY(YourOptionHere) Parameter Details AdvancedDisplay Show on bottom hide details panel Meta UPROPERY(meta = (YourOptionHere = \"Value\", AllowPrivateAccess)) Parameter Details UIMin='0.0', UIMax='1.0 Property clamped 0 to 1 and changed into slider AllowPrivateAccess Allow private / protected modifier to access into Blueprint editcondition=\"someBoolVariableHere\" disable enable this property. You can use condition like floatVal > 1","title":"UProperty and UFunction"},{"location":"programming/cpp/uproperty-ufunction/#uproperty","text":"","title":"UPROPERTY"},{"location":"programming/cpp/uproperty-ufunction/#not-meta","text":"UPROPERTY(YourOptionHere) Parameter Details AdvancedDisplay Show on bottom hide details panel","title":"Not Meta"},{"location":"programming/cpp/uproperty-ufunction/#meta","text":"UPROPERY(meta = (YourOptionHere = \"Value\", AllowPrivateAccess)) Parameter Details UIMin='0.0', UIMax='1.0 Property clamped 0 to 1 and changed into slider AllowPrivateAccess Allow private / protected modifier to access into Blueprint editcondition=\"someBoolVariableHere\" disable enable this property. You can use condition like floatVal > 1","title":"Meta"},{"location":"programming/cpp/variables/","text":"Common Usage Setter Getter is highly recommended. Keep your variable in private / protected is good. When you want to use your variable in the blueprint, use protected and UPROPERTY BlueprintReadWrite / Something else. If you want to use the variable outside of the child class, use public / setter getter. NOTE : if you use set get, dont use blueprintReadWrite at the target variable! Ex: protected : float MoveInput ; public : UFUNCTION ( BlueprintCallable ) FORCEINLINE float GetMoveInput () const { return MoveInput ;} Why? You will have, if you have BlueprintRead, inside the Blueprint, when you call GetMoveInput, it will reproduce 2 type of getter. And that was not good for future development. Just make it simple! Int C++ care about memory, don't overdue int usage, just use it as you need with proper size uint = unsigned int = no negative value int = signed int = allow negative value uint8 = 0 \u2014 255 int8 = -128 \u2014 127 uint16 = 0 \u2014 65535 int16 = -32768 \u2014 32767 uint32 = 0 \u2014 -4294967295 int32 = -2147483648 \u2014 2147483647 Size of c-type data Source : https://www.geeksforgeeks.org/c-data-types/ data type size(in bytes) range SHORT INT 2 -32,768 to 32,767 UNSIGNED SHORT INT 2 0 to 65,535 UNSIGNED INT 4 0 TO 4,294,967,295 INT 4 -2,147,483,648 TO 2,147,483,647 LONG INT 8 -2,147,483,648 TO 2,147,483,647 UNSIGNED LONG INT 8 0 TO 4,294,967,295 LONG LONG INT 8 -(2^63) TO (2^63)-1 UNSIGNED LONG LONG INT 8 0 TO 18,446,744,073,709,551,615 SIGNED CHAR 1 -128 TO 127 UNSIGNED CHAR 1 0 TO 255 FLOAT 4 DOUBLE 8 LONG DOUBLE 12 WCHAR_T 2 OR 4 1 WIDE CHARACTER","title":"Variables"},{"location":"programming/cpp/variables/#common-usage","text":"Setter Getter is highly recommended. Keep your variable in private / protected is good. When you want to use your variable in the blueprint, use protected and UPROPERTY BlueprintReadWrite / Something else. If you want to use the variable outside of the child class, use public / setter getter. NOTE : if you use set get, dont use blueprintReadWrite at the target variable! Ex: protected : float MoveInput ; public : UFUNCTION ( BlueprintCallable ) FORCEINLINE float GetMoveInput () const { return MoveInput ;} Why? You will have, if you have BlueprintRead, inside the Blueprint, when you call GetMoveInput, it will reproduce 2 type of getter. And that was not good for future development. Just make it simple!","title":"Common Usage"},{"location":"programming/cpp/variables/#int","text":"C++ care about memory, don't overdue int usage, just use it as you need with proper size uint = unsigned int = no negative value int = signed int = allow negative value uint8 = 0 \u2014 255 int8 = -128 \u2014 127 uint16 = 0 \u2014 65535 int16 = -32768 \u2014 32767 uint32 = 0 \u2014 -4294967295 int32 = -2147483648 \u2014 2147483647","title":"Int"},{"location":"programming/cpp/variables/#size-of-c-type-data","text":"Source : https://www.geeksforgeeks.org/c-data-types/ data type size(in bytes) range SHORT INT 2 -32,768 to 32,767 UNSIGNED SHORT INT 2 0 to 65,535 UNSIGNED INT 4 0 TO 4,294,967,295 INT 4 -2,147,483,648 TO 2,147,483,647 LONG INT 8 -2,147,483,648 TO 2,147,483,647 UNSIGNED LONG INT 8 0 TO 4,294,967,295 LONG LONG INT 8 -(2^63) TO (2^63)-1 UNSIGNED LONG LONG INT 8 0 TO 18,446,744,073,709,551,615 SIGNED CHAR 1 -128 TO 127 UNSIGNED CHAR 1 0 TO 255 FLOAT 4 DOUBLE 8 LONG DOUBLE 12 WCHAR_T 2 OR 4 1 WIDE CHARACTER","title":"Size of c-type data"},{"location":"random/mixamo/","text":"Mixamo is a resource for your prototype game! But, did you know that it doesn't support for unreal? Don't worry, some guy create a plugin for blender to convert mixamo animation into Unreal humanoid skeleton animation. You can find it in here . This page created for listing animation names, so you don't need to find it one by one. Locomotion Fighting Bare Fighting Sword Bow Pack Scary Zombie Pack Farming Pack Basic Shooter Pack Rifle 8-way Locomotion Pack Pro Melee Axe Pack Magic Locomotion Pack Creature NPC Pack Pro Sword and Shield Pack Lite Longbow Pack Capoeira Pack Locomotion Pack Not So Scary Zombie Pack Breakdance Pack Creature Pack Longbow Locomotion Pack Lite Sword and Shield Pack Action Adventure Pack Male Locomotion Pack Lite Rifle Pack Female Basic Locomotion Lite Magic Pack Soccer Game Pack Pro Longbow Pack Pistol/Handgun Locomotion Scary Zombie Pack Slim Shooter Pack Female Locomotion Pack Male Drunk Pack Basic Locomotion Pack Pro Rifle Pack Free Test Pack Gesture Pack Basic Magic Spell Pack Sword and Shield Pack Pro Melee Axe Pack Pro Magic Pack Great Sword Pack Longbow Aiming Pack Male Injured Pack","title":"Mixamo Animation List"},{"location":"random/mixamo/#locomotion","text":"","title":"Locomotion"},{"location":"random/mixamo/#fighting","text":"","title":"Fighting"},{"location":"random/mixamo/#bare-fighting","text":"","title":"Bare Fighting"},{"location":"random/mixamo/#sword","text":"","title":"Sword"},{"location":"random/mixamo/#bow","text":"","title":"Bow"},{"location":"random/mixamo/#pack","text":"Scary Zombie Pack Farming Pack Basic Shooter Pack Rifle 8-way Locomotion Pack Pro Melee Axe Pack Magic Locomotion Pack Creature NPC Pack Pro Sword and Shield Pack Lite Longbow Pack Capoeira Pack Locomotion Pack Not So Scary Zombie Pack Breakdance Pack Creature Pack Longbow Locomotion Pack Lite Sword and Shield Pack Action Adventure Pack Male Locomotion Pack Lite Rifle Pack Female Basic Locomotion Lite Magic Pack Soccer Game Pack Pro Longbow Pack Pistol/Handgun Locomotion Scary Zombie Pack Slim Shooter Pack Female Locomotion Pack Male Drunk Pack Basic Locomotion Pack Pro Rifle Pack Free Test Pack Gesture Pack Basic Magic Spell Pack Sword and Shield Pack Pro Melee Axe Pack Pro Magic Pack Great Sword Pack Longbow Aiming Pack Male Injured Pack","title":"Pack"}]}